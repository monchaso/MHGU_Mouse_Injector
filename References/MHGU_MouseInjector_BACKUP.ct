<?xml version="1.0" encoding="utf-8"?>
<CheatTable CheatEngineTableVersion="45">
  <CheatEntries>
    <CheatEntry>
      <ID>1</ID>
      <Description>"MHGU Camera Injection (Enable This) [Optimized]"</Description>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>{ Game   : MHGU (Ryujinx)
  Version: 
  Date   : 2026-02-01
  Author : Antigravity
}
[ENABLE]
{$lua}
if syntaxcheck then return end

local symbol = "CameraWrite"
local aob = "89 04 2E 8B 44 24 6C 8D 68 01 89 E8 89 44 24 6C 8B 44 24 70 8D 68 02"

-- Optimization Strategy:
-- 1. Alignment: The target instruction is code, so it is likely 4-byte aligned.
-- 2. Protection: Valid code must be Executable (+X). This skips scanning huge data heaps.

  -- Optimization Strategy:
  -- 1. Alignment: JIT code might not be 4-byte aligned. Using 1 (byte-level) is safer.
  -- 2. Protection: Valid code must be Executable (+X). This is the main speedup.
  -- 3. Caching: Caches the found address to avoid re-scanning on toggle.

  -- Transform string AOB to byte array for comparison
  local aob_bytes = {}
  for b in string.gmatch(aob, "%S+") do table.insert(aob_bytes, tonumber(b, 16)) end

  local function checkCache()
    if CameraWrite_Cache == nil then return false end
    local bytes = readBytes(CameraWrite_Cache, #aob_bytes, true)
    if bytes == nil then return false end
    for i=1, #aob_bytes do
      if bytes[i] ~= aob_bytes[i] then return false end
    end
    return true
  end

  if checkCache() then
     print("&gt;&gt;&gt; Cache hit! Using previously found address.")
     registerSymbol(symbol, CameraWrite_Cache)
  else
      local ms = createMemScan()
      -- Try Executable memory first (Fastest)
      print("&gt;&gt;&gt; Optimized Scan: Searching EXECUTABLE memory (+X)...")
      ms.firstScan(soExactValue, vtByteArray, rtRounded, aob, "", 0, 0x7FFFFFFFFFFFFFFF, "+X", fsmAligned, "1", true, false, false, false)
      ms.waitTillDone()

      local rec = createFoundList(ms)
      rec.initialize()
      if rec.Count &gt; 0 then
        print(string.format("&gt;&gt;&gt; Found %d matches in Executable (+X):", rec.Count))
        for i=0, rec.Count-1 do
            print(string.format("Match %d: %s", i+1, rec.Address[i]))
        end
        CameraWrite_Cache = rec.Address[0]
        registerSymbol(symbol, CameraWrite_Cache)
      else
        -- Fallback: Scan Writable memory (Standard RAM), still byte-aligned
        print("&gt;&gt;&gt; +X Scan failed. Fallback: Searching WRITABLE memory (+W)...")
        rec.destroy()
        ms.destroy()
        
        ms = createMemScan()
        ms.firstScan(soExactValue, vtByteArray, rtRounded, aob, "", 0, 0x7FFFFFFFFFFFFFFF, "+W-C", fsmAligned, "1", true, false, false, false)
        ms.waitTillDone()
        
        rec = createFoundList(ms)
        rec.initialize()
        if rec.Count &gt; 0 then
          print(string.format("&gt;&gt;&gt; Found %d matches in Writable (+W):", rec.Count))
          for i=0, rec.Count-1 do
              print(string.format("Match %d: %s", i+1, rec.Address[i]))
          end
          CameraWrite_Cache = rec.Address[0]
          registerSymbol(symbol, CameraWrite_Cache)
        else
          print("&gt;&gt;&gt; Error: Pattern not found in +X or +W memory.")
          rec.destroy()
          ms.destroy()
          error("Error: Camera AOB pattern not found in memory.")
        end
      end
      
      rec.destroy()
      ms.destroy()
  end
{$asm}

alloc(newmem,2048,CameraWrite)

label(returnhere)
label(originalcode)
label(exit)

label(pCameraBase)
label(pCameraOffset)
registersymbol(pCameraBase)
registersymbol(pCameraOffset)


newmem:
// Capture the addresses
mov [pCameraBase], rsi
mov [pCameraOffset], rbp

originalcode:
mov [rsi+rbp],eax
mov eax,[rsp+6C]
jmp exit

pCameraBase:
dq 0
pCameraOffset:
dq 0

CameraWrite:
jmp newmem
nop
nop
exit:
returnhere:

[DISABLE]
dealloc(newmem)
CameraWrite:
mov [rsi+rbp],eax
mov eax,[rsp+6C]
// db 89 04 2E 8B 44 24 6C

unregistersymbol(pCameraBase)
unregistersymbol(pCameraOffset)
unregistersymbol(CameraWrite)
</AssemblerScript>
      <CheatEntries>
        <CheatEntry>
          <ID>2</ID>
          <Description>"Camera Base (RSI)"</Description>
          <ShowAsHex>1</ShowAsHex>
          <VariableType>8 Bytes</VariableType>
          <Address>pCameraBase</Address>
        </CheatEntry>
        <CheatEntry>
          <ID>3</ID>
          <Description>"Camera Offset (RBP)"</Description>
          <ShowAsHex>1</ShowAsHex>
          <VariableType>8 Bytes</VariableType>
          <Address>pCameraOffset</Address>
        </CheatEntry>
        <CheatEntry>
          <ID>4</ID>
          <Description>"X Axis"</Description>
          <VariableType>4 Bytes</VariableType>
          <Address>[pCameraBase]+[pCameraOffset]</Address>
        </CheatEntry>
        <CheatEntry>
          <ID>5</ID>
          <Description>"Y Axis"</Description>
          <VariableType>4 Bytes</VariableType>
          <Address>[pCameraBase]+[pCameraOffset]-4</Address>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
  </CheatEntries>
  <UserdefinedSymbols>
    <SymbolEntry>
      <Name>CameraWrite</Name>
      <Address>25439BBD684</Address>
    </SymbolEntry>
  </UserdefinedSymbols>
</CheatTable>
